# 数值计算实验2
### 数据科学与计算机学院
### 梁育诚
### 学号 16340133
### 班级 教务二班
---
## 内容1
### 已知 sin(0.32)=0.314567，sin(0.34)=0.333487，sin(0.36)=0.352274，sin(0.38)=0.370920。请采用线性插值、二次插值、三次插值分别计算 sin(0.35)的值。


### 问题描述
&emsp;&emsp;本题涉及到了插值的问题。所谓插值，就是根据已经得到的一些离散的点，通过某种插值方式，求得一个**较为理想**的插值函数，从而求出特定位置的值。这题要求分别使用**线性插值**、**二次插值**、**三次插值**三种插值方式去求得sin(0.35)的值。这三种插值方式可由**拉格朗日插值多项式**统一表达，因此我们只需要写好一个函数，通过输入不同的插值点即可。
### 算法设计
&emsp;&emsp;假设已知n+1个节点，这样就可以构造n次多项式$L_n(x)$，其中$L_n(x)$满足
$$
    L_n(x_j) = y_i, j=0,1,...,n.
$$
也就是说，插值多项式在已知节点上的值必须是和已知值相等的。
&emsp;&emsp;然后我们就需要构造一个完整的插值多项式$L_n(x)$。构造$L_n(x_j)$的一个思路是使用$y_0, y_1,...,yn$这些点的线性组合，我们就需要定义n次插值的基函数$l_j(x)(j=0,1,...,n)$，它满足
$$
    l_j(x_k) = \begin{cases}
1, k = j,\\
0, k \ne j\\
\end{cases}
$$
通过推导，这里直接给出n次插值基函数的形式：
$$
    l_k(x) = \frac{(x-x_0)\dots(x-x_{k-1})(x-x_{k+1})\dots(x-x_n)}{(x_k-x_0)\dots(x_k-x_{k-1})(x_k-x_{k+1})\dots(x_k-x_n)}, k = 0,1,...,n
$$
故我们可以得出完整的**拉格朗日插值多项式**
$$
    L_n(x_j)=\sum^n_{k=0}y_kl_k(x_j) = y_j, j=0,1,...,n
$$
&emsp;&emsp;根据上面得出的拉格朗日插值多项式，我们就可以代入已知的点，根据多项式求出$sin(0.35)$的值了。

### 数值实验
&emsp;&emsp;根据上述推导出来的公式，编写matlab代码：首先计算出所有的基函数，然后使用基函数构成关于$y_k$的线性组合得出插值多项式，最后代入指定的点得出结果。
&emsp;&emsp;线性插值代入两个点，二次插值代入三个点，三次插值代入四个点，然后使用matlab系统自带的函数计算出结果，观察不同次数的插值结果的误差。
matlab代码如下：
```matlab
% 拉格朗日插值
function [y0] = Lagrange(x,y,x0)
format long;
% 给定插值点(x,y)，求在x=x0处的值y0
y0 = 0;
n = length(x);
l = ones(1,n); % 基函数集合
for k = 1:n
    for j = 1:n
        if j ~= k
            l(k) = l(k)*(x0-x(j))/(x(k) - x(j)); % 计算插值基函数
        end
    end
end
% 计算插值多项式
for i = 1:n
    y0 = y0 + y(i)*l(i);
end
```
### 结果分析
测试代码运行结果如下：
![插值结果分析](https://raw.githubusercontent.com/leungyukshing/Numerical-Computation-Methods/master/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/Images/%E6%8F%92%E5%80%BC%E7%BB%93%E6%9E%9C.png)
由上述结果可以看出，插值点越多，计算的结果误差越小。


## 内容2
### 请采用下述方法计算 115 的平方根，精确到小数点后六位。
（1）二分法。选取求根区间为[10, 11]。
（2）牛顿法。
（3）简化牛顿法。
（4）弦截法。
绘出横坐标分别为计算时间、迭代步数时的收敛精度曲线。

### 问题描述
&emsp;&emsp;本题涉及到的是非线性方程的求根方法。非线性问题一般不存在直接求解的方法，大多数都是使用**迭代法**来求解，通过确定误差范围，来求得一个**满意的近似解**。题目要求用到的方法大致可以分为两类：一是通过缩小有根区间而得到近似解的方法，如二分法；二是不动点迭代法，如牛顿法、简化牛顿法和弦截法。
&emsp;&emsp;本题中求解115的平方根可以转化为非线性方程$f(x) = x^2 - 115$的求根问题，下面我将用四种方法来求解。

### 算法设计
#### 1.二分法
&emsp;&emsp;二分法的实现思想是通过迭代的方法来缩小有根区间，最终这个区间必收敛到一点$x^*$，这点就是我们要求的根。在我们实际求解的过程中，没有必要求出这一点$x^*$，我们只需要确定一个误差范围，让这个有根区间的长度小于这个误差即可。
&emsp;&emsp;二分法的核心是如何确定有根区间，首先给出一个较大的有根区间，然后通过不断地二分，通过比对端点值与中点值得正负，来判断根所在的区间。下面给出算法步骤：
**①** 准备：计算$f(x)$在有根区间$[a,b]$端点处的值$f(a)$，$f(b)$。
**②** 二分：计算$f(x)$在区间中点$\frac{a+b}{2}$处的值$f(\frac{a+b}{2})$
**③** 判断：若$f(\frac{a+b}{2})$ = 0，则$\frac{a+b}{2}$就是该非线性方程的根，计算结束，否则检验；若$f(\frac{a+b}{2})f(a)$ < 0，则以$\frac{a+b}{2}$代替$b$成为区间上界，否则以$\frac{a+b}{2}$代替$a$成为区间下界。
重复执行步骤②和步骤③，直至计算结束或区间长度小于规定的误差，此时**中点$\frac{a+b}{2}$为所求的近似根**。
#### 2.牛顿法
&emsp;&emsp;牛顿法的核心思想是将非线性问题转化为线性问题处理。对于非线性方程$f(x)=0$，假设已知有近似根$x_k$（假定$f^{'}(x_k) \ne 0$）,将函数$f(x)$在点$x_k$进行**泰勒展开**，有
$$
    f(x) \approx f(x_k) + f^{'}(x_k)(x-x_k)，
$$
于是方程$f(x) = 0$可以近似地表示为
$$
    f(x_k) + f^{'}(x_k)(x-x_k) = 0,
$$
上面这个是一个线性方程，记其根为$x_{k+1}$，则求得$x_{k+1}$的计算公式为：
$$
    x_{k+1} = x_k - \frac{f(x_k)}{f^{'}(x_k)},
$$
以上的迭代方法就称为**牛顿法**。
#### 3.简化牛顿法
&emsp;&emsp;简化牛顿法是牛顿法的变种，原因在于，牛顿法中每一步都需要计算$f(x_k)$和$f^{'}(x_k)$，这是需要很大计算量的。除此之外，牛顿法中的初始近似$x_0$只在精确解$x^*$附近才能保证收敛。简化牛顿法就是为了解决这个问题的。首先给出简化牛顿法的迭代公式：
$$
    x_{k+1} = x_k - Cf(x_k),
$$
则迭代函数为：$\phi(x) = x - Cf(x)$.
&emsp;&emsp;若$|\phi^{'}(x)| = |1-Cf^{'}(x)| < 1$，即取$0 < Cf^{'}(x) < 2$在根附近成立，则该迭代法局部收敛。
&emsp;&emsp;同时取$C = \frac{1}{f^{'}(x_0)}$，这样就只需要在第一步计算$f^{'}(x_0)$，大大减少了计算量。其几何意义是用斜率为$f^{'}(x_0)$的平行弦与$x$轴交点作为$x^*$的近似解。
#### 4.弦截法
&emsp;&emsp;弦截法也是牛顿法的一个变种，同样也是为了避免计算$f^{'}(x_k)$。这里采用的方法是使用已求的函数值$f(x_k),f(x_{k-1}),...$来回避导数值$f^{'}(x_k)$的计算，这种方法是建立在插值原理的基础上的。
&emsp;&emsp;设$x_k, x_{k-1}$是$f(x) = 0$的近似根，我们利用$f(x_k),f(x_{k-1})$构造一次插值多项式$p_1(x)$，并用$p_1(x) = 0$的根作为$f(x) = 0$的新的近似根$x_{k+1}$，根据一次插值公式：
$$
    p_1(x) = f(x_k) + \frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}(x - x_k)，
$$
因此有
$$
    x_{k+1} = x_k - \frac{f(x_k)}{f(x_k) - f(x_{k-1})}(x_k - x_{k-1})，
$$
以上就是弦截法的迭代公式了。与牛顿法对比，不难看出，弦截法使用$\frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}$代替了牛顿法中的导数$f^{'}(x_k)$。
&emsp;&emsp;弦截法的几何意义是，使用曲线$y = f(x)$上的两点$x_k, x_{k-1}$的弦线与$x$轴的交点作为作为$x^*$的近似解。弦截法与牛顿法都是线性化方法，但是两者有很大不同。牛顿法在计算$x_{k+1}$的时候只用到了上一步的结果$x_k$，而弦截法在求$x_{k+1}$时要用到前两部的计算结果$x_k$，$x_{k-1}$，因此在使用弦截法的时候要首先给出两个值$x_0$，$x_1$。

### 数值实验
#### 1.二分法
&emsp;&emsp;根据上述分析的二分法算法过程，编写matlab代码。
```matlab
% 二分法求解
function [y, k] = dichotomy(a, b)
e = 0.000001;
k = 0;
x = (a + b) / 2;
f1 = myFun(a);
f2 = myFun(b);
fx = myFun(x);

if (fx == 0)
    y = x;
end


while (b-a) > (2*e)
    fx = myFun(x);
    if (fx == 0)
      y = x;
      disp('迭代结束');
      break;
    if (f1 * fx < 0)
        b = x;
        f2 = fx;
    else
        a = x;
        f1 = fx;
    end
    y = x;
    k = k + 1;
    x = (a + b) / 2;
end
end

% 求解函数
function [y] = myFun(x)
y = x*x - 115;
end

```
#### 2.牛顿法
&emsp;&emsp;根据上述分析得出的牛顿法迭代公式，编写matlab代码。
```matlab
function [y, time] = Newton(x, e, n)
    % y为最终结果
    % time为迭代步数
    % x为开始迭代的初始坐标
    % e为迭代精度
    % n为最大迭代次数
    del_x = 0.0000001; % 用于求函数导数值的极小量
    time = 0;
    y = x;
    x = y + 1000; % 保证迭代能开始
    while 1
        if (abs(y-x) <= e)
            disp('满足迭代精度');
            break;
        elseif (time > n)
            disp('迭代次数超界');
        else
            x = y;
            if((myFun(x+del_x) - myFun(x)) == 0)
                disp('导数为0');
                break;
            else
                y_deriv = (myFun(x+del_x) - myFun(x)) / del_x; %x点的导数值
                y = x - myFun(x) / y_deriv; % 牛顿迭代
                time = time + 1; %迭代次数加1
            end
        end
    end
    disp('牛顿迭代结束');
end


function [y] = myFun(x)
y = x*x - 115;
end
```
#### 3.简化牛顿法
&emsp;&emsp;简化牛顿法可以先在一开始就计算出$f^{'}(x_0)$，随后在循环过程中直接使用就可以了。
```matlab
```
#### 4.弦截法
&emsp;&emsp;根据上面推导的迭代函数，编写代码。
```matlab
```
### 结果分析

## 内容3
### 请采用递推最小二乘法求解超定线性方程组 Ax=b，其中 A 为 mⅹn 维的已知矩阵，b 为m 维的已知向量，x 为 n 维的未知向量，其中 n=10，m=10000。A 与 b 中的元素服从独立同分布的正态分布。绘出横坐标为迭代步数时的收敛精度曲线。

### 问题描述
### 算法设计
### 数值实验
### 结果分析


## 内容4
### 请编写 1024 点快速傅里叶变换的算法。自行生成一段混杂若干不同频率正弦的信号，测试所编写的快速傅里叶变换算法。

## 内容5
### 请采用复合梯形公式与复合辛普森公式，计算 sin(x)/x 在[0, 1]范围内的积分。采样点数目为 5、9、17、33。

### 问题描述
&emsp;&emsp;本题要解决的是一个数值积分问题，对于一些难于求积的函数，使用**牛顿-莱布尼茨**公式显然是不科学的。因此对于这类问题，我们可以从**积分中值定理**出发，使用矩形或梯形的面积去近似积分值。
### 算法设计
&emsp;&emsp;这道题要求用到**复合梯形公式**和**复合辛普森公式**，统称为**复合求积法**。这种通过把积分区间细分成若干个子区间（通常是等分），再在每个子区间上使用低阶求积公式，从而提高了计算精度。
#### 复合梯形公式
&emsp;&emsp;该公式核心思想是对于细分后的每一个子区间，使用梯形公式求积。假设将区间$[a,b]$等分为$n$个子区间，分点$x_k = a + kh，h = \frac{b-a}{n}，k=0,1,...,n$，公式的原理就是对于每一块小梯形而言，上底为$f(x_k)$，下底为$f(x_{k+1})$，高为$h$。
&emsp;&emsp;复合梯形公式如下：
$$
I = \int^b_af(x)dx = \sum^{n-1}_{k=0}\int^{x_{k+1}}_{x_k}f(x)dx = \frac{h}{2}\sum^{n-1}_{k=0}[f(x_k) + f(x_{k+1})]，
$$
而在计算机编程时，通常使用的是下面这个形式:
$$
    T_n = \frac{h}{2}\sum^{n-1}_{k=0}[f(x_k) + f(x_{k+1})] = \frac{h}{2}[f(a)+2\sum^{n-1}_{k=1}f(x_k) + f(b)]
$$


#### 复合辛普森公式

### 数值实验
### 结果分析


## 内容6
### 请采用下述方法，求解常微分方程初值问题 y’=y-2x/y，y(0)=1，计算区间为[0, 1]，步长为 0.1。
（1）前向欧拉法。
（2）后向欧拉法。
（3）梯形方法。
（4）改进欧拉方法。

### 问题描述
### 数值实验
### 结果分析
